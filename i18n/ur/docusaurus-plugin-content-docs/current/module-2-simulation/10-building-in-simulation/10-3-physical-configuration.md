# سبق 10.3: طبعی ترتیب (Gazebo-مخصوص ٹیگز)

URDF ایک عمومی مقصد کا فارمیٹ ہے، لیکن سمیلیٹرز کو اکثر اس سے زیادہ معلومات کی ضرورت ہوتی ہے جو یہ فراہم کر سکتا ہے۔ اسے حل کرنے کے لیے، ہم اپنی URDF فائل میں `<gazebo>` بلاک کے اندر Gazebo-مخصوص ٹیگز شامل کر سکتے ہیں۔ سمیلیٹر ان ٹیگز کو پڑھے گا، لیکن دوسرے ROS ٹولز انہیں نظر انداز کر دیں گے۔

یہ ٹیگز ہمیں رگڑ، ڈیمپنگ، مادی خصوصیات کی وضاحت کرنے، اور اپنی URDF کو Gazebo پلگ انز سے جوڑنے کی اجازت دیتے ہیں۔

## `<gazebo>` ٹیگ

آپ `<link>` یا `<joint>` ٹیگ کے اندر ایک `<gazebo>` ٹیگ شامل کر سکتے ہیں۔ اگر آپ ایک لنک کے لیے خصوصیات کی وضاحت کر رہے ہیں، تو ٹیگ `<gazebo reference="link_name">` ہے۔

## رگڑ شامل کرنا

آئیے اپنے پہیوں اور کاسٹر میں رگڑ کی خصوصیات شامل کرتے ہیں تاکہ وہ برف پر پھسلنے کی طرح پھسلیں نہ۔ ہم تصادم جیومیٹری کے لیے رگڑ کے گتانک کی وضاحت کریں گے۔

```xml
<!-- two_wheeled_robot.urdf کے اندر -->

<gazebo reference="left_wheel">
  <mu1>0.9</mu1>
  <mu2>0.9</mu2>
  <material>Gazebo/Black</material>
</gazebo>

<gazebo reference="right_wheel">
  <mu1>0.9</mu1>
  <mu2>0.9</mu2>
  <material>Gazebo/Black</material>
</gazebo>

<gazebo reference="caster">
  <mu1>0.0</mu1>
  <mu2>0.0</mu2>
  <material>Gazebo/Grey</material>
</gazebo>
```
*   **`reference="link_name"`**: یہ وصف Gazebo کو بتاتا ہے کہ یہ خصوصیات کس لنک پر لاگو ہوتی ہیں۔
*   **`<mu1>` اور `<mu2>`**: یہ پرائمری اور سیکنڈری رگڑ کی سمتوں کے لیے رگڑ کے گتانک ہیں۔ ایک پہیے کے لیے، ہم زیادہ رگڑ چاہتے ہیں۔ ہمارے سادہ کاسٹر کے لیے، ہم اسے پھسلنے والا بنانے کے لیے صفر پر سیٹ کریں گے۔
*   **`<material>`**: یہ Gazebo کو اس کے بلٹ ان مٹیریل سکرپٹس میں سے ایک کو رینڈرنگ کے لیے استعمال کرنے کے لیے کہتا ہے۔ یہ روبوٹ کو سمیلیٹر میں ان سادہ رنگوں کے مقابلے میں بہت بہتر دکھائے گا جن کی ہم نے `<visual>` ٹیگ میں وضاحت کی تھی۔

## Gazebo پلگ ان شامل کرنا

`<gazebo>` ٹیگ کا سب سے طاقتور استعمال پلگ انز کو منسلک کرنا ہے۔ ایک پلگ ان کوڈ کا ایک ٹکڑا ہے جو سیمولیشن کے اندر چلتا ہے اور آپ کے روبوٹ اور ROS 2 نیٹ ورک کے ساتھ تعامل کر سکتا ہے۔

ہمیں اپنے ڈیفرینشل ڈرائیو روبوٹ کو کنٹرول کرنے کے لیے ایک پلگ ان کی ضرورت ہے۔ `ros_gz_bridge` پیکیج ایک پلگ ان فراہم کرتا ہے جسے `gz::sim::systems::DiffDrive` کہا جاتا ہے۔

ہم اس پلگ ان کو اپنی URDF میں، `chassis` لنک کے ساتھ منسلک کرتے ہیں۔
```xml
<gazebo>
  <plugin
    name="gz::sim::systems::DiffDrive"
    filename="gz-sim-diff-drive-system">
    <left_joint>left_wheel_joint</left_joint>
    <right_joint>right_wheel_joint</right_joint>
    <wheel_separation>0.35</wheel_separation>
    <wheel_radius>0.1</wheel_radius>
    <odom_publish_frequency>10</odom_publish_frequency>
    <topic>/cmd_vel</topic>
  </plugin>
</gazebo>
```
*   **`<plugin>`**: لوڈ کرنے کے لیے پلگ ان کی وضاحت کرتا ہے۔
*   **`<left_joint>` اور `<right_joint>`**: وہیل جوائنٹس کے نام۔
*   **`<wheel_separation>`**: دونوں پہیوں کے درمیان فاصلہ (میٹرز میں)۔ یہ آپ کے جوائنٹ اوریجنز میں `y` ویلیو سے ملنا چاہیے۔
*   **`<wheel_radius>`**: پہیوں کا رداس۔ یہ آپ کے لنک جیومیٹری میں رداس سے ملنا چاہیے۔
*   **`<topic>`**: یہ اہم حصہ ہے۔ پلگ ان `geometry_msgs/msg/Twist` پیغامات کے لیے اس ROS 2 ٹاپک کو سبسکرائب کرے گا۔ اس طرح ہم اپنے روبوٹ کو کنٹرول کریں گے۔ ہم نے اسے `/cmd_vel` پر سیٹ کیا ہے۔

## مکمل URDF

ان سب کو ایک ساتھ ملا کر، آپ کی URDF فائل اب ایک ہائبرڈ فائل ہے جس میں معیاری URDF ٹیگز اور Gazebo-مخصوص ایکسٹینشنز دونوں شامل ہیں۔ یہ ROS ڈویلپمنٹ میں ایک بہت عام پیٹرن ہے۔

اب جب آپ اپنی `gazebo.launch.py` فائل لانچ کریں گے، تو آپ کا روبوٹ اسپان ہونا چاہیے اور زمین پر صحیح طریقے سے بیٹھنا چاہیے۔ یہ اب ایک طبعی طور پر حقیقت پسندانہ ماڈل ہے۔

اس سے بھی بہتر، یہ اب قابل کنٹرول ہے۔ جب سیمولیشن چل رہی ہو، ایک نیا ٹرمینل کھولیں اور `/cmd_vel` ٹاپک پر `Twist` پیغام بھیجنے کے لیے `ros2 topic pub` استعمال کریں۔
```bash
ros2 topic pub --rate 1 /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}}"
```
آپ کا سمیولیٹڈ روبوٹ آگے بڑھنا شروع کر دے گا! `DiffDrive` پلگ ان ROS 2 پیغام وصول کر رہا ہے اور اسے فورسز میں تبدیل کر رہا ہے جو یہ فزکس سیمولیشن کے اندر وہیل جوائنٹس پر لاگو کرتا ہے۔

اب آپ نے ایک مکمل ڈیجیٹل ٹوئن بنایا ہے۔ اگلے ابواب میں، ہم سمیولیٹڈ سینسرز کو شامل کرنے اور زیادہ پیچیدہ، کلوزڈ-لوپ کنٹرولرز بنانے کا طریقہ دریافت کریں گے۔
