# سبق 12.4: مہارتیں تخلیق کرنا

"وال فالور" جو آپ نے پچھلے سبق میں بنایا تھا وہ ایک **مہارت** یا **رویے** کی ایک مثال ہے۔ یہ ایک خود مختار ROS 2 نوڈ (یا نوڈس کا مجموعہ) ہے جو ایک مخصوص، دوبارہ قابل استعمال کام انجام دیتا ہے۔

جدید روبوٹکس مونو لیتھک، ہارڈ کوڈڈ کنٹرول پروگراموں سے ہٹ کر قابل ترتیب مہارتوں کی ایک لائبریری کی طرف بڑھ رہا ہے۔ ایک اعلیٰ سطحی پلانر پھر پیچیدہ اہداف کو حاصل کرنے کے لیے ان مہارتوں کو ترتیب دے سکتا ہے۔

## ایک اچھی مہارت کی خصوصیات

*   **ماڈیولر:** یہ ایک واضح انٹرفیس کے ساتھ ایک خود مختار ROS 2 پیکیج ہونا چاہیے۔
*   **قابل ترتیب:** اسے نئے روبوٹس یا ماحول میں آسان ٹیوننگ اور موافقت کے لیے پیرامیٹرز کا استعمال کرنا چاہیے۔ ہمارے وال فالور میں `desired_distance` اور `k_proportional` کے لیے پیرامیٹرز ہو سکتے ہیں۔
*   **واضح API:** اس کی پیشرفت کو شروع کرنے، روکنے، اور نگرانی کرنے کا ایک واضح طریقہ ہونا چاہیے۔ سادہ مہارتوں کے لیے، صرف نوڈ کو چلانا کافی ہے۔ زیادہ پیچیدہ مہارتوں کے لیے، آپ عام طور پر ایک ROS 2 **ایکشن** استعمال کریں گے (جس کا ہم مستقبل کے ماڈیول میں احاطہ کریں گے)۔ ایک ایکشن ایک مقصد بھیجنے کا ایک رسمی طریقہ فراہم کرتا ہے (مثلاً، "10 میٹر کے لیے دیوار کے ساتھ چلیں")، فیڈ بیک حاصل کرتا ہے، اور حتمی نتیجہ حاصل کرتا ہے۔

## مثال: ایک "Go to Goal" مہارت

آئیے ایک اور مہارت ڈیزائن کرتے ہیں۔ یہ ہمارے روبوٹ کو ایک مخصوص (x, y) کوآرڈینیٹ پر لے جائے گی۔

*   **نوڈ کا نام:** `go_to_goal_node`
*   **سبسکرائب کرتا ہے:**
    *   `/odom` (`nav_msgs/msg/Odometry`): روبوٹ کی موجودہ پوزیشن اور واقفیت حاصل کرنے کے لیے۔ ہم اپنے روبوٹ کے لیے Gazebo کی پوز کی معلومات کو برج کرنے کے لیے `ros_gz_bridge` کا استعمال کرتے ہوئے یہ ٹاپک حاصل کریں گے۔
*   **شائع کرتا ہے:**
    *   `/cmd_vel` (`geometry_msgs/msg/Twist`): روبوٹ کی حرکت کو کنٹرول کرنے کے لیے۔
*   **ایکشن سرور:**
    *   `/go_to_goal` (`my_interfaces/action/GoToGoal`): ہدف کوآرڈینیٹ وصول کرنے کے لیے ایک ایکشن سرور۔
*   **منطق:**
    1.  ایک ہدف (x, y) پوز کے ساتھ ایک مقصد وصول کریں۔
    2.  ایک کنٹرول لوپ میں، مسلسل:
        a.  `/odom` سے موجودہ پوز پڑھیں۔
        b.  موجودہ پوز اور مقصد پوز کے درمیان غلطی کا حساب لگائیں۔
        c.  غلطی کو کم کرنے کے لیے `linear.x` اور `angular.z` رفتار کا حساب لگائیں (یہ وال فالور سے زیادہ پیچیدہ تناسب کنٹرولر ہے)۔
        d.  رفتار کمانڈ کو `/cmd_vel` پر شائع کریں۔
        e.  مقصد تک موجودہ فاصلے کے ساتھ ایکشن ٹاپک پر فیڈ بیک شائع کریں۔
    3.  جب غلطی صفر کے قریب ہو، تو روبوٹ کو روکیں اور رپورٹ کریں کہ مقصد کامیابی سے حاصل ہو گیا۔

## مہارتوں کو ترتیب دینا

ایک بار جب آپ کے پاس ان مہارتوں کی ایک لائبریری ہو جاتی ہے، تو ایک اعلیٰ سطحی "دماغ" نوڈ پیچیدہ کاموں کو انجام دینے کے لیے انہیں استعمال کر سکتا ہے۔

تصور کریں کہ آپ کے پاس مہارتیں ہیں:
*   `GoToGoal`
*   `FindObject` (ایک کیمرہ کا استعمال کرتے ہوئے)
*   `PickUpObject` (ایک روبوٹک بازو کا استعمال کرتے ہوئے)

ایک دماغ نوڈ "دوسرے کمرے سے مجھے سرخ گیند لاؤ" جیسا کمانڈ وصول کر سکتا ہے اور اسے ان مہارت ایکشن سرورز کو کالز کی ایک ترتیب میں ترجمہ کر سکتا ہے:
1.  "دوسرے کمرے" کے کوآرڈینیٹس کے ساتھ `GoToGoal` کو کال کریں۔
2.  ایک بار جب وہ کامیاب ہو جائے، تو "سرخ گیند" کو ہدف کے طور پر `FindObject` کو کال کریں۔
3.  ایک بار جب وہ کامیاب ہو جائے (گیند کی پوزیشن واپس کر دے)، تو گیند کی پوزیشن کے ساتھ `GoToGoal` کو کال کریں۔
4.  ایک بار جب وہ کامیاب ہو جائے، تو `PickUpObject` کو کال کریں۔

یہ درجہ بندی شدہ، رویے پر مبنی فن تعمیر پیچیدہ خود مختار نظام بنانے کا ایک طاقتور اور قابل توسیع طریقہ ہے۔ آپ صرف کوڈ نہیں لکھ رہے ہیں؛ آپ دوبارہ قابل استعمال روبوٹک صلاحیتوں کی ایک لائبریری بنا رہے ہیں۔

یہ باب 12 کا اختتام کرتا ہے۔ اب آپ اپنے ROS 2 نوڈس کو Gazebo سیمولیشن کے ساتھ کیسے مربوط کرنا ہے تاکہ کلوزڈ-لوپ رویے بنائے جا سکیں، یہ سمجھتے ہیں۔ اس ماڈیول کے آخری باب میں، آپ ماڈیول 2 کیپسٹون پروجیکٹ کو مکمل کرنے کے لیے ان تمام ٹکڑوں کو ایک ساتھ جوڑیں گے۔
