"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[9902],{8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var o=i(6540);const s={},t=o.createContext(s);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(t.Provider,{value:n},e.children)}},9038:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-simulation/robot-description-formats/9-1-understanding-urdf","title":"Lesson 9.1: Understanding URDF","description":"The Unified Robot Description Format (URDF) is an XML-based file format for representing a robot model. At its core, a URDF file describes the robot as a tree of links and joints.","source":"@site/docs/module-2-simulation/9-robot-description-formats/9-1-understanding-urdf.md","sourceDirName":"module-2-simulation/9-robot-description-formats","slug":"/module-2-simulation/robot-description-formats/9-1-understanding-urdf","permalink":"/hackathon/docs/module-2-simulation/robot-description-formats/9-1-understanding-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/docs/module-2-simulation/9-robot-description-formats/9-1-understanding-urdf.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 9: Robot Description Formats","permalink":"/hackathon/docs/module-2-simulation/robot-description-formats/"},"next":{"title":"Lesson 9.2: Building Your First Robot","permalink":"/hackathon/docs/module-2-simulation/robot-description-formats/9-2-building-first-robot"}}');var s=i(4848),t=i(8453);const r={},l="Lesson 9.1: Understanding URDF",d={},c=[{value:"The Link-Joint Tree",id:"the-link-joint-tree",level:2},{value:"The <code>&lt;robot&gt;</code> Tag",id:"the-robot-tag",level:2},{value:"The <code>&lt;link&gt;</code> Tag",id:"the-link-tag",level:2},{value:"The <code>&lt;joint&gt;</code> Tag",id:"the-joint-tag",level:2}];function a(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lesson-91-understanding-urdf",children:"Lesson 9.1: Understanding URDF"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Unified Robot Description Format (URDF)"})," is an XML-based file format for representing a robot model. At its core, a URDF file describes the robot as a tree of ",(0,s.jsx)(n.strong,{children:"links"})," and ",(0,s.jsx)(n.strong,{children:"joints"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Link:"})," A rigid part of the robot's body (e.g., a leg, a wheel, a chassis)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joint:"})," A connection between two links that defines how one link can move relative to the other."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-link-joint-tree",children:"The Link-Joint Tree"}),"\n",(0,s.jsxs)(n.p,{children:["A URDF model must be a tree. This means there are no closed loops. One link must be specified as the ",(0,s.jsx)(n.strong,{children:"root link"}),", and all other links are connected to it through a chain of joints."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"base_link (root)\n  \u251c\u2500\u2500 right_leg_joint\n  \u2502   \u2514\u2500\u2500 right_leg_link\n  \u2502       \u2514\u2500\u2500 right_foot_joint\n  \u2502           \u2514\u2500\u2500 right_foot_link\n  \u251c\u2500\u2500 left_leg_joint\n  \u2502   \u2514\u2500\u2500 left_leg_link\n  ...\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"the-robot-tag",children:["The ",(0,s.jsx)(n.code,{children:"<robot>"})," Tag"]}),"\n",(0,s.jsxs)(n.p,{children:["Every URDF file starts and ends with a ",(0,s.jsx)(n.code,{children:"<robot>"})," tag. This tag has one attribute, ",(0,s.jsx)(n.code,{children:"name"}),", which is the name of the robot."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<robot name="my_robot">\n  ... all your links and joints go here ...\n</robot>\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"the-link-tag",children:["The ",(0,s.jsx)(n.code,{children:"<link>"})," Tag"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<link>"})," tag defines a rigid part of the robot."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="my_link_name">\n  ...\n</link>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Inside the link tag, you will typically define three things: ",(0,s.jsx)(n.code,{children:"<visual>"}),", ",(0,s.jsx)(n.code,{children:"<collision>"}),", and ",(0,s.jsx)(n.code,{children:"<inertial>"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<visual>"}),":"]})," This describes what the link ",(0,s.jsx)(n.em,{children:"looks like"}),". It's used for visualization in tools like RViz and Gazebo.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<geometry>"}),": Can be a simple shape like ",(0,s.jsx)(n.code,{children:"<box>"}),", ",(0,s.jsx)(n.code,{children:"<cylinder>"}),", or ",(0,s.jsx)(n.code,{children:"<sphere>"}),", or it can be a 3D mesh file like ",(0,s.jsx)(n.code,{children:'<mesh filename="package://my_package/meshes/my_link.stl" />'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<material>"}),": Defines the color of the link."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<collision>"}),":"]})," This describes the physical bounding box of the link for the physics engine. It is often a simpler shape than the visual geometry to speed up collision checking. It has its own ",(0,s.jsx)(n.code,{children:"<geometry>"})," tag."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<inertial>"}),":"]})," This describes the physical properties of the link: its mass and its moment of inertia. This is crucial for accurate physics simulation."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"the-joint-tag",children:["The ",(0,s.jsx)(n.code,{children:"<joint>"})," Tag"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<joint>"})," tag connects two links together."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="my_joint_name" type="revolute">\n  <parent link="parent_link_name"/>\n  <child link="child_link_name"/>\n  <origin xyz="0 0 1.0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>\n</joint>\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"name"})," and ",(0,s.jsx)(n.code,{children:"type"}),":"]})," Every joint has a name and a type. The most common types are:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"revolute"}),": A hinge joint that rotates around a single axis (like an elbow)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"continuous"}),": A revolute joint with no angle limits (like a wheel)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prismatic"}),": A sliding joint that moves along an axis."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fixed"}),": A joint that doesn't move. This is used to rigidly connect two links."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<parent>"})," and ",(0,s.jsx)(n.code,{children:"<child>"}),":"]})," These tags define the tree structure. The joint connects the ",(0,s.jsx)(n.code,{children:"child"})," link to the ",(0,s.jsx)(n.code,{children:"parent"})," link."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<origin>"}),":"]})," This is a crucial tag. It defines the ",(0,s.jsx)(n.strong,{children:"transform"})," (position and orientation) of the child link's origin relative to the parent link's origin. ",(0,s.jsx)(n.code,{children:"xyz"})," is the position offset, and ",(0,s.jsx)(n.code,{children:"rpy"})," (roll, pitch, yaw) is the orientation offset."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<axis>"}),":"]})," For revolute and prismatic joints, this defines the axis of motion. ",(0,s.jsx)(n.code,{children:'xyz="0 0 1"'})," means the joint rotates around the Z-axis."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"<limit>"}),":"]})," For revolute and prismatic joints, this defines the joint's limits: ",(0,s.jsx)(n.code,{children:"lower"})," and ",(0,s.jsx)(n.code,{children:"upper"})," for position, ",(0,s.jsx)(n.code,{children:"effort"})," for the maximum force it can apply, and ",(0,s.jsx)(n.code,{children:"velocity"})," for the maximum speed."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By combining these simple building blocks, you can describe the kinematics of almost any robot, from a simple mobile cart to a complex humanoid. In the next lesson, you'll use these tags to build your first robot."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);