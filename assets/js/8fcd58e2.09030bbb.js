"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[4918],{4163:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros/capstone/7-2-building-the-controller","title":"Lesson 7.2: Building the Controller","description":"With a clear specification, the coding becomes much more straightforward. We are no longer designing on the fly; we are simply implementing the plan we\'ve already made.","source":"@site/docs/module-1-ros/7-capstone/7-2-building-the-controller.md","sourceDirName":"module-1-ros/7-capstone","slug":"/module-1-ros/capstone/7-2-building-the-controller","permalink":"/hackathon/docs/module-1-ros/capstone/7-2-building-the-controller","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/docs/module-1-ros/7-capstone/7-2-building-the-controller.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Lesson 7.1: The Specification","permalink":"/hackathon/docs/module-1-ros/capstone/7-1-capstone-specification"},"next":{"title":"Lesson 7.3: Testing & Validation","permalink":"/hackathon/docs/module-1-ros/capstone/7-3-testing-and-validation"}}');var t=r(4848),a=r(8453);const i={},l="Lesson 7.2: Building the Controller",o={},c=[{value:"1. Create the Custom Service",id:"1-create-the-custom-service",level:2},{value:"2. Implement the <code>shape_drawer_node</code>",id:"2-implement-the-shape_drawer_node",level:2},{value:"3. Create the Launch File",id:"3-create-the-launch-file",level:2},{value:"4. Register, Build, and Run",id:"4-register-build-and-run",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lesson-72-building-the-controller",children:"Lesson 7.2: Building the Controller"})}),"\n",(0,t.jsx)(n.p,{children:"With a clear specification, the coding becomes much more straightforward. We are no longer designing on the fly; we are simply implementing the plan we've already made."}),"\n",(0,t.jsx)(n.p,{children:"This lesson is a culmination of everything you've learned. You will need to create a new service interface, write a complex node that acts as both a service server and a publisher, and create a launch file to tie it all together."}),"\n",(0,t.jsx)(n.h2,{id:"1-create-the-custom-service",children:"1. Create the Custom Service"}),"\n",(0,t.jsxs)(n.p,{children:["First, let's create the ",(0,t.jsx)(n.code,{children:"DrawShape.srv"})," file in your ",(0,t.jsx)(n.code,{children:"my_custom_interfaces"})," package."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Create file:"})," ",(0,t.jsx)(n.code,{children:"my_custom_interfaces/srv/DrawShape.srv"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"float32 edge_length\nint32 sides\n---\nbool success\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Edit ",(0,t.jsx)(n.code,{children:"CMakeLists.txt"}),":"]})," Add the new service file to the ",(0,t.jsx)(n.code,{children:"rosidl_generate_interfaces"})," call.","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cmake",children:'rosidl_generate_interfaces(${PROJECT_NAME}\n  "msg/Person.msg"\n  "srv/SendPerson.srv"\n  "srv/DrawShape.srv"  # Add this\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"2-implement-the-shape_drawer_node",children:["2. Implement the ",(0,t.jsx)(n.code,{children:"shape_drawer_node"})]}),"\n",(0,t.jsxs)(n.p,{children:["Create a new file, ",(0,t.jsx)(n.code,{children:"my_first_package/shape_drawer.py"}),". The code for this node is more complex as it combines several concepts."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# my_first_package/my_first_package/shape_drawer.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom my_custom_interfaces.srv import DrawShape\nimport time\nimport math\n\nclass ShapeDrawerNode(Node):\n    def __init__(self):\n        super().__init__('shape_drawer_node')\n        \n        # Declare parameters\n        self.declare_parameter('linear_velocity', 1.0)\n        self.declare_parameter('angular_velocity', 1.0)\n        \n        # Create publisher for velocity commands\n        self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)\n        \n        # Create the service server\n        self.srv = self.create_service(DrawShape, 'draw_shape', self.draw_shape_callback)\n        \n        self.get_logger().info('Shape Drawer Node has been started.')\n\n    def draw_shape_callback(self, request, response):\n        linear_vel = self.get_parameter('linear_velocity').get_parameter_value().double_value\n        angular_vel = self.get_parameter('angular_velocity').get_parameter_value().double_value\n        \n        edge_length = request.edge_length\n        sides = request.sides\n\n        self.get_logger().info(f'Drawing a shape with {sides} sides of length {edge_length}.')\n\n        # Calculate times needed for movement and turning\n        move_duration = edge_length / linear_vel\n        turn_angle = 2 * math.pi / sides\n        turn_duration = turn_angle / angular_vel\n\n        # Loop to draw the shape\n        for i in range(sides):\n            # Move forward\n            self.publish_velocity(linear_vel, 0.0)\n            time.sleep(move_duration)\n            \n            # Stop\n            self.publish_velocity(0.0, 0.0)\n            time.sleep(0.1)\n\n            # Turn\n            self.publish_velocity(0.0, angular_vel)\n            time.sleep(turn_duration)\n\n            # Stop\n            self.publish_velocity(0.0, 0.0)\n            time.sleep(0.1)\n\n        self.get_logger().info('Shape drawing complete.')\n        response.success = True\n        return response\n\n    def publish_velocity(self, linear, angular):\n        msg = Twist()\n        msg.linear.x = linear\n        msg.angular.z = angular\n        self.publisher_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    shape_drawer_node = ShapeDrawerNode()\n    rclpy.spin(shape_drawer_node)\n    shape_drawer_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," The use of ",(0,t.jsx)(n.code,{children:"time.sleep()"})," here is a simple approach for this exercise. In a real, production-quality robot, you would use more sophisticated feedback-based control (e.g., checking the turtle's pose from the ",(0,t.jsx)(n.code,{children:"/turtle1/pose"})," topic) rather than relying on fixed-time movements."]}),"\n",(0,t.jsx)(n.h2,{id:"3-create-the-launch-file",children:"3. Create the Launch File"}),"\n",(0,t.jsxs)(n.p,{children:["Create ",(0,t.jsx)(n.code,{children:"launch/capstone.launch.py"})," in your ",(0,t.jsx)(n.code,{children:"my_first_package"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# my_first_package/launch/capstone.launch.py\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='turtlesim',\n            executable='turtlesim_node',\n            name='turtlesim'\n        ),\n        Node(\n            package='my_first_package',\n            executable='shape_drawer',\n            name='shape_drawer_node',\n            parameters=[\n                {'linear_velocity': 0.5},\n                {'angular_velocity': 0.5}\n            ]\n        )\n    ])\n"})}),"\n",(0,t.jsx)(n.h2,{id:"4-register-build-and-run",children:"4. Register, Build, and Run"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Register Node:"})," Add ",(0,t.jsx)(n.code,{children:"shape_drawer = my_first_package.shape_drawer:main"})," to your ",(0,t.jsx)(n.code,{children:"setup.py"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Add Dependency:"})," Add ",(0,t.jsx)(n.code,{children:"<depend>my_custom_interfaces</depend>"})," to the ",(0,t.jsx)(n.code,{children:"package.xml"})," of ",(0,t.jsx)(n.code,{children:"my_first_package"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build:"})," Run ",(0,t.jsx)(n.code,{children:"colcon build"})," from your workspace root. It should build both ",(0,t.jsx)(n.code,{children:"my_custom_interfaces"})," and ",(0,t.jsx)(n.code,{children:"my_first_package"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"source install/setup.bash"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch the system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 launch my_first_package capstone.launch.py\n"})}),"\n","This will start both the Turtlesim simulator and your controller node. Your system is now running and waiting for a command."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In the final lesson, we will test the system against our specification."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);