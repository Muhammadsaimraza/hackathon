"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[9627],{2629:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-simulation/building-in-simulation/10-3-physical-configuration","title":"Lesson 10.3: Physical Configuration (Gazebo-Specific Tags)","description":"URDF is a general-purpose format, but simulators often need more information than it can provide. To solve this, we can add Gazebo-specific tags to our URDF file inside a `` block. The simulator will read these tags, but other ROS tools will simply ignore them.","source":"@site/docs/module-2-simulation/10-building-in-simulation/10-3-physical-configuration.md","sourceDirName":"module-2-simulation/10-building-in-simulation","slug":"/module-2-simulation/building-in-simulation/10-3-physical-configuration","permalink":"/hackathon/docs/module-2-simulation/building-in-simulation/10-3-physical-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/docs/module-2-simulation/10-building-in-simulation/10-3-physical-configuration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Lesson 10.2: Models from Fuel","permalink":"/hackathon/docs/module-2-simulation/building-in-simulation/10-2-models-from-fuel"},"next":{"title":"Lesson 10.4: World Building with AI","permalink":"/hackathon/docs/module-2-simulation/building-in-simulation/10-4-world-building-with-ai"}}');var s=n(4848),t=n(8453);const l={},r="Lesson 10.3: Physical Configuration (Gazebo-Specific Tags)",a={},c=[{value:"The <code>&lt;gazebo&gt;</code> Tag",id:"the-gazebo-tag",level:2},{value:"Adding Friction",id:"adding-friction",level:2},{value:"Adding a Gazebo Plugin",id:"adding-a-gazebo-plugin",level:2},{value:"The Full URDF",id:"the-full-urdf",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"lesson-103-physical-configuration-gazebo-specific-tags",children:"Lesson 10.3: Physical Configuration (Gazebo-Specific Tags)"})}),"\n",(0,s.jsxs)(i.p,{children:["URDF is a general-purpose format, but simulators often need more information than it can provide. To solve this, we can add Gazebo-specific tags to our URDF file inside a ",(0,s.jsx)(i.code,{children:"<gazebo>"})," block. The simulator will read these tags, but other ROS tools will simply ignore them."]}),"\n",(0,s.jsx)(i.p,{children:"These tags allow us to define friction, damping, material properties, and to connect our URDF to Gazebo plugins."}),"\n",(0,s.jsxs)(i.h2,{id:"the-gazebo-tag",children:["The ",(0,s.jsx)(i.code,{children:"<gazebo>"})," Tag"]}),"\n",(0,s.jsxs)(i.p,{children:["You can add a ",(0,s.jsx)(i.code,{children:"<gazebo>"})," tag inside a ",(0,s.jsx)(i.code,{children:"<link>"})," or a ",(0,s.jsx)(i.code,{children:"<joint>"})," tag. If you are defining properties for a link, the tag is ",(0,s.jsx)(i.code,{children:'<gazebo reference="link_name">'}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"adding-friction",children:"Adding Friction"}),"\n",(0,s.jsx)(i.p,{children:"Let's add friction properties to our wheels and caster so they don't slide around like they're on ice. We will define friction coefficients for the collision geometry."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Inside two_wheeled_robot.urdf --\x3e\n\n<gazebo reference="left_wheel">\n  <mu1>0.9</mu1>\n  <mu2>0.9</mu2>\n  <material>Gazebo/Black</material>\n</gazebo>\n\n<gazebo reference="right_wheel">\n  <mu1>0.9</mu1>\n  <mu2>0.9</mu2>\n  <material>Gazebo/Black</material>\n</gazebo>\n\n<gazebo reference="caster">\n  <mu1>0.0</mu1>\n  <mu2>0.0</mu2>\n  <material>Gazebo/Grey</material>\n</gazebo>\n'})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:'reference="link_name"'})}),": This attribute tells Gazebo which link these properties apply to."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:[(0,s.jsx)(i.code,{children:"<mu1>"})," and ",(0,s.jsx)(i.code,{children:"<mu2>"})]}),": These are the coefficients of friction for the primary and secondary friction directions. For a wheel, we want high friction. For our simple caster, we'll set it to zero to make it slippery."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"<material>"})}),": This tells Gazebo to use one of its built-in material scripts for rendering. This will make the robot look much nicer in the simulator than the simple colors we defined in the ",(0,s.jsx)(i.code,{children:"<visual>"})," tag."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"adding-a-gazebo-plugin",children:"Adding a Gazebo Plugin"}),"\n",(0,s.jsxs)(i.p,{children:["The most powerful use of the ",(0,s.jsx)(i.code,{children:"<gazebo>"})," tag is to attach plugins. A plugin is a piece of code that runs inside the simulation and can interact with your robot and the ROS 2 network."]}),"\n",(0,s.jsxs)(i.p,{children:["We need a plugin to control our differential drive robot. The ",(0,s.jsx)(i.code,{children:"ros_gz_bridge"})," package provides one called ",(0,s.jsx)(i.code,{children:"gz::sim::systems::DiffDrive"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["We add this plugin to our URDF, associated with the ",(0,s.jsx)(i.code,{children:"chassis"})," link."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<gazebo>\n  <plugin\n    name="gz::sim::systems::DiffDrive"\n    filename="gz-sim-diff-drive-system">\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.35</wheel_separation>\n    <wheel_radius>0.1</wheel_radius>\n    <odom_publish_frequency>10</odom_publish_frequency>\n    <topic>/cmd_vel</topic>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"<plugin>"})}),": Defines the plugin to load."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:[(0,s.jsx)(i.code,{children:"<left_joint>"})," and ",(0,s.jsx)(i.code,{children:"<right_joint>"})]}),": The names of the wheel joints."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"<wheel_separation>"})}),": The distance between the two wheels (in meters). This must match the ",(0,s.jsx)(i.code,{children:"y"})," value in your joint origins."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"<wheel_radius>"})}),": The radius of the wheels. This must match the radius in your link geometry."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"<topic>"})}),": This is the crucial part. The plugin will subscribe to this ROS 2 topic for ",(0,s.jsx)(i.code,{children:"geometry_msgs/msg/Twist"})," messages. This is how we will control our robot. We've set it to ",(0,s.jsx)(i.code,{children:"/cmd_vel"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"the-full-urdf",children:"The Full URDF"}),"\n",(0,s.jsx)(i.p,{children:"Putting it all together, your URDF file is now a hybrid file containing both standard URDF tags and Gazebo-specific extensions. This is a very common pattern in ROS development."}),"\n",(0,s.jsxs)(i.p,{children:["When you launch your ",(0,s.jsx)(i.code,{children:"gazebo.launch.py"})," file now, your robot should spawn and sit correctly on the ground. It is now a physically realistic model."]}),"\n",(0,s.jsxs)(i.p,{children:["Even better, it is now controllable. While the simulation is running, open a new terminal and use ",(0,s.jsx)(i.code,{children:"ros2 topic pub"})," to send a ",(0,s.jsx)(i.code,{children:"Twist"})," message to the ",(0,s.jsx)(i.code,{children:"/cmd_vel"})," topic."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:'ros2 topic pub --rate 1 /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}}"\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Your simulated robot will start to move forward! The ",(0,s.jsx)(i.code,{children:"DiffDrive"})," plugin is receiving the ROS 2 message and converting it into forces that it applies to the wheel joints inside the physics simulation."]}),"\n",(0,s.jsx)(i.p,{children:"You have now created a complete digital twin. In the next chapters, we will explore how to add simulated sensors and build more complex, closed-loop controllers."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>r});var o=n(6540);const s={},t=o.createContext(s);function l(e){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(t.Provider,{value:i},e.children)}}}]);