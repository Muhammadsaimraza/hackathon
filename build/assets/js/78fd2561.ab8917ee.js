"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[8444],{8453:(e,o,t)=>{t.d(o,{R:()=>a,x:()=>r});var n=t(6540);const i={},s=n.createContext(i);function a(e){const o=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:o},e.children)}},9812:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"module-4-humanoid-vla/kinematics-dynamics/18-1-kinematics-the-geometry-of-motion","title":"Lesson 18.1: Kinematics: The Geometry of Motion","description":"Kinematics is the \\"geometry of motion.\\" It\'s a mathematical framework for describing the position, orientation, and velocity of the robot\'s body parts without considering the forces involved. For a robot arm or leg, there are two fundamental kinematic problems.","source":"@site/docs/module-4-humanoid-vla/18-kinematics-dynamics/18-1-kinematics-the-geometry-of-motion.md","sourceDirName":"module-4-humanoid-vla/18-kinematics-dynamics","slug":"/module-4-humanoid-vla/kinematics-dynamics/18-1-kinematics-the-geometry-of-motion","permalink":"/robolearn/docs/module-4-humanoid-vla/kinematics-dynamics/18-1-kinematics-the-geometry-of-motion","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/robolearn/tree/main/docs/module-4-humanoid-vla/18-kinematics-dynamics/18-1-kinematics-the-geometry-of-motion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 18: Humanoid Kinematics & Dynamics","permalink":"/robolearn/docs/module-4-humanoid-vla/kinematics-dynamics/"},"next":{"title":"Lesson 18.2: Dynamics: The Physics of Motion","permalink":"/robolearn/docs/module-4-humanoid-vla/kinematics-dynamics/18-2-dynamics-the-physics-of-motion"}}');var i=t(4848),s=t(8453);const a={},r="Lesson 18.1: Kinematics: The Geometry of Motion",l={},h=[{value:"1. Forward Kinematics (FK)",id:"1-forward-kinematics-fk",level:2},{value:"2. Inverse Kinematics (IK)",id:"2-inverse-kinematics-ik",level:2},{value:"The IK Solver",id:"the-ik-solver",level:2}];function c(e){const o={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.header,{children:(0,i.jsx)(o.h1,{id:"lesson-181-kinematics-the-geometry-of-motion",children:"Lesson 18.1: Kinematics: The Geometry of Motion"})}),"\n",(0,i.jsx)(o.p,{children:"Kinematics is the \"geometry of motion.\" It's a mathematical framework for describing the position, orientation, and velocity of the robot's body parts without considering the forces involved. For a robot arm or leg, there are two fundamental kinematic problems."}),"\n",(0,i.jsx)(o.h2,{id:"1-forward-kinematics-fk",children:"1. Forward Kinematics (FK)"}),"\n",(0,i.jsxs)(o.p,{children:[(0,i.jsx)(o.strong,{children:"The Question:"}),' "Given a set of joint angles, where is the robot\'s hand?"']}),"\n",(0,i.jsx)(o.p,{children:'This is the "easy" problem. Your URDF file is essentially a description of the forward kinematics of your robot. It defines the length of each link and the position and orientation of each joint.'}),"\n",(0,i.jsx)(o.p,{children:"If you know the angle of the shoulder joint, the elbow joint, and the wrist joint, you can use a series of matrix multiplications (one for each link's transform) to calculate the exact 3D position and orientation of the robot's hand (its \"end-effector\") relative to its base."}),"\n",(0,i.jsxs)(o.p,{children:["The ROS ",(0,i.jsx)(o.code,{children:"robot_state_publisher"})," node does this continuously. It reads the joint angles from the ",(0,i.jsx)(o.code,{children:"/joint_states"})," topic, performs the forward kinematics calculation, and publishes the resulting link poses as a TF tree. This is how RViz knows where to draw your robot."]}),"\n",(0,i.jsx)(o.h2,{id:"2-inverse-kinematics-ik",children:"2. Inverse Kinematics (IK)"}),"\n",(0,i.jsxs)(o.p,{children:[(0,i.jsx)(o.strong,{children:"The Question:"}),' "If I want to place the robot\'s hand at a specific target position, what should the joint angles be?"']}),"\n",(0,i.jsx)(o.p,{children:'This is the "hard" problem. It is the inverse of the FK problem, and it is much more difficult to solve.'}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.strong,{children:"Multiple Solutions:"})," For a typical robot arm with 6 or 7 joints, there are often multiple, and sometimes infinite, possible sets of joint angles that will result in the same end-effector position. Think about touching your nose: you can do it with your elbow high or your elbow low. Both are valid IK solutions."]}),"\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.strong,{children:"No Solution:"})," If you try to reach for a target that is outside the robot's workspace, there is no solution."]}),"\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.strong,{children:"Computational Cost:"})," Solving the IK equations can be computationally expensive, and it needs to be done very quickly for real-time control."]}),"\n"]}),"\n",(0,i.jsx)(o.h2,{id:"the-ik-solver",children:"The IK Solver"}),"\n",(0,i.jsxs)(o.p,{children:["Because this problem is so hard, we don't solve it ourselves. We use a specialized piece of software called an ",(0,i.jsx)(o.strong,{children:"IK solver"}),"."]}),"\n",(0,i.jsx)(o.p,{children:"An IK solver is a library that takes a target pose for the end-effector and the robot's URDF as input, and it calculates a valid set of joint angles as output."}),"\n",(0,i.jsxs)(o.p,{children:["ROS has a standard framework for motion planning called ",(0,i.jsx)(o.strong,{children:"MoveIt"}),", which has a pluggable architecture for IK solvers. You can choose from a variety of different solvers based on your robot and your needs."]}),"\n",(0,i.jsx)(o.p,{children:'When you use a motion planner to say "move the arm to this target," the first thing the planner does is call the IK solver to find out what the final joint angles need to be. The planner then creates a trajectory through the joint space to move from the current angles to the target angles while avoiding collisions.'})]})}function d(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);