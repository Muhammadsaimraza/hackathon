"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[7626],{8453:(e,o,n)=>{n.d(o,{R:()=>r,x:()=>a});var t=n(6540);const s={},i=t.createContext(s);function r(e){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:o},e.children)}},8463:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-2-simulation/ros2-gazebo-integration/12-2-spawning-robots","title":"Lesson 12.2: Spawning Robots (Review)","description":"We briefly covered this in Chapter 10, but it\'s worth looking at the mechanism for adding your robot to the simulation in more detail.","source":"@site/docs/module-2-simulation/12-ros2-gazebo-integration/12-2-spawning-robots.md","sourceDirName":"module-2-simulation/12-ros2-gazebo-integration","slug":"/module-2-simulation/ros2-gazebo-integration/12-2-spawning-robots","permalink":"/robolearn/docs/module-2-simulation/ros2-gazebo-integration/12-2-spawning-robots","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/robolearn/tree/main/docs/module-2-simulation/12-ros2-gazebo-integration/12-2-spawning-robots.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Lesson 12.1: The ros_gz_bridge","permalink":"/robolearn/docs/module-2-simulation/ros2-gazebo-integration/12-1-ros-gz-bridge"},"next":{"title":"Lesson 12.3: Closed-Loop Control","permalink":"/robolearn/docs/module-2-simulation/ros2-gazebo-integration/12-3-closed-loop-control"}}');var s=n(4848),i=n(8453);const r={},a="Lesson 12.2: Spawning Robots (Review)",l={},d=[{value:"The <code>create</code> Executable",id:"the-create-executable",level:2},{value:"How it Works Under the Hood",id:"how-it-works-under-the-hood",level:2},{value:"Why Spawn Instead of Include?",id:"why-spawn-instead-of-include",level:2}];function c(e){const o={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"lesson-122-spawning-robots-review",children:"Lesson 12.2: Spawning Robots (Review)"})}),"\n",(0,s.jsx)(o.p,{children:"We briefly covered this in Chapter 10, but it's worth looking at the mechanism for adding your robot to the simulation in more detail."}),"\n",(0,s.jsxs)(o.p,{children:["You cannot include a URDF file directly in a world SDF file. The SDF standard does not have an ",(0,s.jsx)(o.code,{children:"<include>"})," tag for URDFs. Instead, the standard workflow is:"]}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsx)(o.li,{children:"Start the Gazebo simulation with a world file that contains the environment (ground, lights, obstacles, etc.)."}),"\n",(0,s.jsxs)(o.li,{children:["Use a separate mechanism to ",(0,s.jsx)(o.strong,{children:"spawn"})," the robot's URDF model into the running simulation."]}),"\n"]}),"\n",(0,s.jsxs)(o.h2,{id:"the-create-executable",children:["The ",(0,s.jsx)(o.code,{children:"create"})," Executable"]}),"\n",(0,s.jsxs)(o.p,{children:["The ",(0,s.jsx)(o.code,{children:"ros_gz_sim"})," package provides a helpful executable for this purpose, called ",(0,s.jsx)(o.code,{children:"create"}),". As we saw before, we can use it in a launch file like this:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-python",children:"# From a launch file\n\nrobot_urdf = os.path.join(get_package_share_directory('my_package'), 'urdf', 'my_robot.urdf')\n\nspawn_robot_node = Node(\n    package='ros_gz_sim',\n    executable='create',\n    arguments=[\n        '-file', robot_urdf,\n        '-name', 'my_robot',\n        '-x', '0.0',\n        '-y', '0.0',\n        '-z', '0.1'\n    ],\n    output='screen',\n)\n"})}),"\n",(0,s.jsx)(o.h2,{id:"how-it-works-under-the-hood",children:"How it Works Under the Hood"}),"\n",(0,s.jsxs)(o.p,{children:["The ",(0,s.jsx)(o.code,{children:"create"})," executable is a convenience wrapper that does two things:"]}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"It reads your URDF file."})," It parses the XML and holds the robot's description in memory."]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"It calls a Gazebo service."})," Gazebo has a built-in service that allows you to add new models to the world while it's running. The ",(0,s.jsx)(o.code,{children:"create"})," node calls this service and passes it the robot's description from the URDF file."]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:'The service call is essentially saying, "Hey Gazebo, please add a new model to your world. Here is the description of the model." Gazebo then adds the robot to its physics engine and starts simulating it.'}),"\n",(0,s.jsx)(o.h2,{id:"why-spawn-instead-of-include",children:"Why Spawn Instead of Include?"}),"\n",(0,s.jsxs)(o.p,{children:["This two-step process might seem more complicated than just including the robot in the world file, but it provides a critical advantage: ",(0,s.jsx)(o.strong,{children:"modularity"}),"."]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"Robot and World are Decoupled:"})," Your robot's URDF file is completely separate from your world SDF file. This means you can test the ",(0,s.jsx)(o.em,{children:"same robot"})," in ",(0,s.jsx)(o.em,{children:"many different worlds"})," without having to edit any files. You can simply pass a different world file path to your launch file."]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.strong,{children:"Dynamic Spawning:"})," You can spawn robots at any time, not just at the beginning of the simulation. You could have a ROS 2 node that decides to spawn a new robot in response to some event."]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"This separation of the robot from its environment is a fundamental concept in ROS and Gazebo. It allows you to create reusable robot models and reusable test environments, and then mix and match them as needed."}),"\n",(0,s.jsx)(o.p,{children:"In the next lesson, we will use the topics provided by our spawned robot's sensors to create a closed-loop controller."})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);