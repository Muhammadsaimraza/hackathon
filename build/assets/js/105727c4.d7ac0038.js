"use strict";(globalThis.webpackChunkrobolearn=globalThis.webpackChunkrobolearn||[]).push([[152],{3908:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-simulation/robot-description-formats/9-3-physical-properties","title":"Lesson 9.3: Physical Properties","description":"Your robot looks right in RViz, but as far as a physics engine is concerned, it\'s a ghost. It has no mass, no friction, and no substance. To simulate the robot in a tool like Gazebo, we need to add its physical properties.","source":"@site/docs/module-2-simulation/9-robot-description-formats/9-3-physical-properties.md","sourceDirName":"module-2-simulation/9-robot-description-formats","slug":"/module-2-simulation/robot-description-formats/9-3-physical-properties","permalink":"/robolearn/docs/module-2-simulation/robot-description-formats/9-3-physical-properties","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadsaimraza/robolearn/tree/main/docs/module-2-simulation/9-robot-description-formats/9-3-physical-properties.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Lesson 9.2: Building Your First Robot","permalink":"/robolearn/docs/module-2-simulation/robot-description-formats/9-2-building-first-robot"},"next":{"title":"Lesson 9.4: URDF with AI","permalink":"/robolearn/docs/module-2-simulation/robot-description-formats/9-4-urdf-with-ai"}}');var s=n(4848),t=n(8453);const r={},l="Lesson 9.3: Physical Properties",a={},c=[{value:"<code>&lt;collision&gt;</code>",id:"collision",level:2},{value:"<code>&lt;inertial&gt;</code>",id:"inertial",level:2},{value:"How to Calculate Inertia?",id:"how-to-calculate-inertia",level:3},{value:"Adding to Our Robot",id:"adding-to-our-robot",level:2}];function d(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"lesson-93-physical-properties",children:"Lesson 9.3: Physical Properties"})}),"\n",(0,s.jsxs)(i.p,{children:["Your robot ",(0,s.jsx)(i.em,{children:"looks"})," right in RViz, but as far as a physics engine is concerned, it's a ghost. It has no mass, no friction, and no substance. To simulate the robot in a tool like Gazebo, we need to add its physical properties."]}),"\n",(0,s.jsxs)(i.p,{children:["This is done using two tags inside each ",(0,s.jsx)(i.code,{children:"<link>"}),": ",(0,s.jsx)(i.code,{children:"<collision>"})," and ",(0,s.jsx)(i.code,{children:"<inertial>"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"collision",children:(0,s.jsx)(i.code,{children:"<collision>"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"<collision>"})," tag defines the shape of the link for the physics engine. It's often a good idea to make this shape simpler than the ",(0,s.jsx)(i.code,{children:"<visual>"})," shape. For example, you might have a very detailed visual mesh with thousands of polygons, but use a simple box or cylinder for the collision geometry. This makes the physics calculations much faster."]}),"\n",(0,s.jsx)(i.p,{children:"For our simple robot, the visual and collision geometries can be the same."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<link name="chassis">\n  <visual>\n    <geometry>\n      <box size="0.5 0.3 0.1"/>\n    </geometry>\n    ...\n  </visual>\n  \n  <collision>\n    <geometry>\n      <box size="0.5 0.3 0.1"/>\n    </geometry>\n  </collision>\n  \n  ...\n</link>\n'})}),"\n",(0,s.jsxs)(i.p,{children:["You should add a ",(0,s.jsx)(i.code,{children:"<collision>"})," tag to every link in your robot that you want to interact with the world."]}),"\n",(0,s.jsx)(i.h2,{id:"inertial",children:(0,s.jsx)(i.code,{children:"<inertial>"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"<inertial>"})," tag is the most critical for a realistic simulation. It defines the mass and moment of inertia for the link."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<link name="chassis">\n  ...\n  <inertial>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <mass value="5.0"/>\n    <inertia \n      ixx="0.04" ixy="0.0" ixz="0.0"\n      iyy="0.1" iyyy="0.0"\n      izz="0.12"/>\n  </inertial>\n</link>\n'})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:[(0,s.jsx)(i.code,{children:"<origin>"}),":"]})," The center of mass for the link, relative to the link's origin. For a symmetrical shape, this is usually ",(0,s.jsx)(i.code,{children:'xyz="0 0 0"'}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:[(0,s.jsx)(i.code,{children:"<mass>"}),":"]})," The mass of the link in kilograms."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:[(0,s.jsx)(i.code,{children:"<inertia>"}),":"]})," The ",(0,s.jsx)(i.strong,{children:"moment of inertia tensor"}),". This 3x3 matrix describes how the link's mass is distributed around its center of mass. It determines how the link will react to rotational forces (torques).","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"ixx"}),", ",(0,s.jsx)(i.code,{children:"iyy"}),", ",(0,s.jsx)(i.code,{children:"izz"}),": These are the moments of inertia about the X, Y, and Z axes."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"ixy"}),", ",(0,s.jsx)(i.code,{children:"ixz"}),", ",(0,s.jsx)(i.code,{children:"iyz"}),": These are the products of inertia. For symmetrical shapes, these are often zero."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"how-to-calculate-inertia",children:"How to Calculate Inertia?"}),"\n",(0,s.jsx)(i.p,{children:"Calculating the inertia tensor for a complex shape is difficult. Fortunately, for common shapes, there are standard formulas:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Box:"})," ",(0,s.jsx)(i.code,{children:"Ixx = (1/12) * m * (y^2 + z^2)"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Cylinder:"})," ",(0,s.jsx)(i.code,{children:"Ixx = (1/12) * m * (3*r^2 + h^2)"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Sphere:"})," ",(0,s.jsx)(i.code,{children:"Ixx = (2/5) * m * r^2"})]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Most CAD programs can also calculate the mass and inertia tensor for a model automatically if you define the material (e.g., aluminum, steel). For our purposes, we can use approximate values."}),"\n",(0,s.jsx)(i.h2,{id:"adding-to-our-robot",children:"Adding to Our Robot"}),"\n",(0,s.jsxs)(i.p,{children:["Let's add these properties to our ",(0,s.jsx)(i.code,{children:"two_wheeled_robot.urdf"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'\x3c!-- two_wheeled_robot.urdf --\x3e\n<robot name="two_wheeled_robot">\n\n  \x3c!-- ***** LINKS ***** --\x3e\n\n  <link name="chassis">\n    <visual> ... </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.04" ixy="0.0" ixz="0.0" iyy="0.1" iyyy="0.0" izz="0.12"/>\n    </inertial>\n  </link>\n\n  <link name="left_wheel">\n    <visual> ... </visual>\n    <collision>\n      <origin xyz="0 0 0" rpy="1.5707 0 0"/>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.002" iyyy="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- ... Do the same for right_wheel and caster ... --\x3e\n\n  \x3c!-- ***** JOINTS ***** --\x3e\n  ...\n</robot>\n'})}),"\n",(0,s.jsxs)(i.p,{children:["You need to add ",(0,s.jsx)(i.code,{children:"<collision>"})," and ",(0,s.jsx)(i.code,{children:"<inertial>"})," tags to every link."]}),"\n",(0,s.jsx)(i.p,{children:"With these tags added, your robot is no longer a ghost. It is a physical object that a simulator like Gazebo can bring to life. In the next chapter, we will do exactly that: import this robot into a Gazebo world and make it move."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>l});var o=n(6540);const s={},t=o.createContext(s);function r(e){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(t.Provider,{value:i},e.children)}}}]);